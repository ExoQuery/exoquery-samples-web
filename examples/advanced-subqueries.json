{
  "title": "Advanced Subqueries",
  "slug": "advanced-subqueries",
  "icon": "üîç",
  "category": "Advanced",
  "description": "Using subqueries for complex filtering",
  "code": "import io.exoquery.*\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class Product(val id: Int, val name: String, val price: Int, val categoryId: Int)\n\n@Serializable\ndata class Category(val id: Int, val name: String, val minPrice: Int)\n\n//sampleStart\nval expensiveProducts = sql.select {\n    val p = from(Table<Product>())\n    val avgPrice = sql { \n        Table<Product>().map { it.price }.avg() \n    }\n    where { p.price > avgPrice }\n    p\n}\n//sampleEnd\n\nfun main(): Unit = expensiveProducts.buildPrettyFor.Postgres().runSample()",
  "output": "SELECT\n  p.id,\n  p.name,\n  p.price,\n  p.categoryId\nFROM\n  Product p\nWHERE\n  p.price > (\n    SELECT AVG(p2.price)\n    FROM Product p2\n  )",
  "schema": "CREATE TABLE Product (id SERIAL PRIMARY KEY, name VARCHAR(100), price INT, categoryId INT);\nCREATE TABLE Category (id SERIAL PRIMARY KEY, name VARCHAR(100), minPrice INT);\n\nINSERT INTO Product (id, name, price, categoryId) VALUES\n  (1, 'Lunar Boots', 150, 1),\n  (2, 'Solar Panel Kit', 500, 2),\n  (3, 'Space Suit', 1200, 1),\n  (4, 'Oxygen Tank', 300, 2);\n\nINSERT INTO Category (id, name, minPrice) VALUES\n  (1, 'Apparel', 100),\n  (2, 'Equipment', 200);",
  "try": [
    "Try using `IN` with a subquery to filter by category",
    "Try correlating the subquery with the outer query",
    "Add a `HAVING` clause with a subquery in the aggregation"
  ]
}